#!/usr/bin/python# -*- coding: UTF-8 -*-#调用RSeQC获得质控结果，并将对应的结果图片移动到指定的位置import osimport sysimport reimport operator import subprocessfrom pdf2image import convert_from_pathimport tempfile#检测文件是否存在的模块from pathlib import Path#################################################################################class myRSeQC:	def __init__(self,out_rseqc,out_png,layout,output_name,read_ALIGNMENT_LENGTH,input_name,species): 		self.out_png = out_png 		self.output_name = output_name 		self.layout = layout 		self.out_rseqc = out_rseqc 		self.read_ALIGNMENT_LENGTH = read_ALIGNMENT_LENGTH 		self.input_name = input_name 		self.species = species 	################################################	#Functions	#将结果图片从pdf变为png的函数	def pdf_to_png(self,filename, output):		#https://blog.csdn.net/qq_17197861/article/details/81502489		print("Converting the resulting PDF file to a PNG file.")		with tempfile.TemporaryDirectory() as path:			images = convert_from_path(filename)			images[0].save(output)		return	################################################	def os_system(self,my_str):		# popen返回文件对象，跟open操作一样		f = os.popen(my_str).read()		return f	################################################	def my_clipping_profile(self):		try:			print("Calculating the distributions of clipped nucleotides across reads.")			self.os_system('clipping_profile.py -i '+self.input_name+' -s '+self.layout+' -o '+self.out_rseqc+self.output_name)			print("Detecting the result of calculating!")			if operator.eq(self.layout,"PE"):				if os.path.getsize(self.out_rseqc+self.output_name+'.clipping_profile.R1.pdf')>3611:					if os.path.getsize(self.out_rseqc+self.output_name+'.clipping_profile.R2.pdf')>3611:						print("The work of drawing profile of clipping is successful !")						self.pdf_to_png(self.out_rseqc+self.output_name+'.clipping_profile.R1.pdf', self.out_png+self.output_name+'_clipping_profile_R1.png')						self.pdf_to_png(self.out_rseqc+self.output_name+'.clipping_profile.R2.pdf', self.out_png+self.output_name+'_clipping_profile_R2.png')					else:						print("read-2 count is zero!")						sys.exit()				else:					print("read-1 count is zero!")					sys.exit()			elif operator.eq(self.layout,"SE"):				if os.path.getsize(self.out_rseqc+self.output_name+'.clipping_profile.pdf')>3611:					print("The work of drawing profile of clipping is successful !")					self.pdf_to_png(self.out_rseqc+self.output_name+'.clipping_profile.pdf', self.out_png+self.output_name+'_clipping_profile.png')				else:					print("read-1 count is zero!")					sys.exit()			else:				print("Please input the correct self.layout!\nFor example:'SE' or 'PE'")				sys.exit()		except:			print("Error,the work of drawing profile of clipping was failed!")			sys.exit()		print('#############################################################################################')		return	################################################	def my_samtools(self):		print("Samtools is working.")		try:			self.os_system('samtools sort -m 1000000000 '+self.input_name+' -o '+self.out_rseqc+self.output_name+'.sorted.bam')			if os.path.getsize(self.out_rseqc+self.output_name+'.sorted.bam')>1:				print("The work of samtools is successful!")					self.os_system('samtools index '+self.out_rseqc+self.output_name+'.sorted.bam')			else:				print("Error,the work of samtools was failed!")				sys.exit()		except:			print("Error,the work of samtools was failed!")			sys.exit()		print('#############################################################################################')		return	################################################	def my_deletion_profile(self):		print("Calculating the distributions of deletions across reads.")		try:			result = self.read_ALIGNMENT_LENGTH			self.os_system('deletion_profile.py -i '+self.out_rseqc+self.output_name+'.sorted.bam -l '+result+' -o '+self.out_rseqc+self.output_name)			if os.path.getsize(self.out_rseqc+self.output_name+'.deletion_profile.txt')>1:				print("The deletion distribution between different reads is calculated successfully.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.deletion_profile.pdf', self.out_png+self.output_name+'_deletion_profile.png')			else:				print("Calculating the deletion distribution between reads failed.")				sys.exit()		except:			print("Error,calculating the distributions of deletions across reads failed.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_geneBody_coverage(self):		print('Calculating the RNA-seq reads coverage over gene body.')		try:			self.os_system('geneBody_coverage.py -r ./files/'+self.species+'.HouseKeepingGenes.bed -i '+self.out_rseqc+self.output_name+'.sorted.bam -o '+self.out_png+self.output_name+' -f "png"')			#if os.path.getsize(self.out_png+self.output_name+'.geneBodyCoverage.txt')>1:			if os.path.isfile(self.out_png+self.output_name+'.geneBodyCoverage.curves.png'):				print("Successful coverage of genomes that can be read by computing RNA sequences.")				self.os_system('mv '+self.out_png+self.output_name+'.geneBodyCoverage.curves.png '+self.out_png+self.output_name+'_geneBodyCoverage_curves.png')			elif os.path.getsize(self.out_png+self.output_name+'.geneBodyCoverage.txt')>1:				print('Cannot get coverage signal from out.sorted.bam ! Skip')			else:				print("Failure to calculate the coverage of RNA sequences that can read genomes.")				sys.exit()		except:			print("Error,failure to calculate the coverage of RNA sequences that can read genomes.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_inner_distance(self):		print('Calculating inner distance between read pairs.')		try:			self.os_system('inner_distance.py -i '+self.out_rseqc+self.output_name+'.sorted.bam -o '+self.out_rseqc+self.output_name+' -r ./files/'+self.species+'_RefSeq.bed')			if os.path.getsize(self.out_rseqc+self.output_name+'.inner_distance_freq.txt')>1:				print("Successful calculation of internal distance between read pairs.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.inner_distance_plot.pdf',self.out_png+self.output_name+'_inner_distance_plot.png')			else:				print("Failure to calculate inner distance between read pairs.")				sys.exit()		except:			print("Error,failure to calculate inner distance between read pairs.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_insertion_profile(self):		print('Calculating the distributions of inserted nucleotides across reads.')		try:			self.os_system('insertion_profile.py -s '+self.layout+' -i '+self.out_rseqc+self.output_name+'.sorted.bam -o '+self.out_rseqc+self.output_name)			print("Detecting this result!")			if operator.eq(self.layout,"PE"):				if os.path.getsize(self.out_rseqc+self.output_name+'.insertion_profile.R1.pdf')>3611 :					if os.path.getsize(self.out_rseqc+self.output_name+'.insertion_profile.R2.pdf')>3611:						print("Successful calculation of the distribution of inserted nucleotides in reading operations.")						self.pdf_to_png(self.out_rseqc+self.output_name+'.insertion_profile.R1.pdf', self.out_png+self.output_name+'_insertion_profile_R1.png')						self.pdf_to_png(self.out_rseqc+self.output_name+'.insertion_profile.R2.pdf', self.out_png+self.output_name+'_insertion_profile_R2.png')					else:						print("Failure to calculate the distributions of inserted nucleotides across reads.(R2)")						sys.exit()				else:					print("Failure to calculate the distributions of inserted nucleotides across reads.(R1)")					sys.exit()			elif operator.eq(self.layout,"SE"):				if os.path.getsize(self.out_rseqc+self.output_name+'.insertion_profile.pdf')>3611 :						print("Successful calculation of the distribution of inserted nucleotides in reading operations.")						self.pdf_to_png(self.out_rseqc+self.output_name+'.insertion_profile.pdf', self.out_png+self.output_name+'_insertion_profile.png')				else:					print("Failure to calculate the distributions of inserted nucleotides across reads.")					sys.exit()			else:				print("Please input the correct self.layout!\nFor example:'SE' or 'PE'")				sys.exit()		except:			print("Error,failure to calculate the distributions of inserted nucleotides across reads.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_junction_annotation(self):		try:			print("To compare detected splice junctions to reference gene model. ")			self.os_system('junction_annotation.py -i '+self.input_name+' -o '+self.out_rseqc+self.output_name+' -r ./files/'+self.species+'_RefSeq.bed')			#my_file = Path(file_path)			if os.path.getsize(self.out_rseqc+self.output_name+'.junction.xls')>1:				print("The detected splicing joints were compared with the reference gene model successfully.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.splice_junction.pdf',self.out_png+self.output_name+'_splice_junction.png')				self.pdf_to_png(self.out_rseqc+self.output_name+'.splice_events.pdf',self.out_png+self.output_name+'_splice_events.png')			elif not os.path.isfile(self.out_rseqc+self.output_name+'.splice_junction.pdf'):				print("No splice junction found.")			else:				print(os.path.isfile(self.out_rseqc+self.output_name+'.splice_junction.pdf'))				print("Failure to compare detected splice junctions to reference gene model.")				sys.exit()		except:			print("Error,failure to compare detected splice junctions to reference gene model.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_junction_saturation(self):		try:			print("This module checks for saturation by resampling 5%, 10%, 15%, ..., 95% of total alignments from BAM or SAM file, and then detects splice junctions from each subset and compares them to reference gene model.")			self.os_system('junction_saturation.py -i '+self.input_name+' -o '+self.out_rseqc+self.output_name+' -r ./files/'+self.species+'_RefSeq.bed')			if os.path.getsize(self.out_rseqc+self.output_name+'.junctionSaturation_plot.pdf')>3611:				print("Successful comparison with reference gene model.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.junctionSaturation_plot.pdf',self.out_png+self.output_name+'_junctionSaturation_plot.png')			else:				print("Failure to compare with reference gene model.")				sys.exit()		except:			print("Error,failure to compare with reference gene model.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_mismatch_profile(self):		try:			print("Calculating the distribution of mismatches across reads. ")			result = self.read_ALIGNMENT_LENGTH			self.os_system('mismatch_profile.py -l '+result+' -i '+self.input_name+' -o '+self.out_rseqc+self.output_name)			if os.path.getsize(self.out_rseqc+self.output_name+'.mismatch_profile.xls')>1:				print("Successful distribution of mismatches between different reads.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.mismatch_profile.pdf',self.out_png+self.output_name+'_mismatch_profile.png')			else:				print("Failure to calculate the distribution of mismatches across reads.")				sys.exit()		except:			print("Error,failure to calculate the distribution of mismatches across reads.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_read_duplication(self):		try:			print("Two strategies were used to determine reads duplication rate.")			self.os_system('read_duplication.py -i '+self.input_name+' -o '+self.out_rseqc+self.output_name)			if os.path.getsize(self.out_rseqc+self.output_name+'.seq.DupRate.xls')>1:				print("Two strategies are used to determine the success rate of read repetition.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.DupRate_plot.pdf',self.out_png+self.output_name+'_DupRate_plot.png')			else:				print("Two strategies are used to determine the read repetition rate failure.")				sys.exit()		except:			print("Error,two strategies are used to determine the read repetition rate failure.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_read_GC(self):		try:			print("GC content distribution of reads.")			self.os_system('read_GC.py -i '+self.input_name+' -o '+self.out_rseqc+self.output_name)			if os.path.getsize(self.out_rseqc+self.output_name+'.GC.xls')>1:				print("The GC content read was successfully distributed.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.GC_plot.pdf',self.out_png+self.output_name+'_GC_plot.png')			else:				print("The GC content distribution read failed.")				sys.exit()		except:			print("Error,the GC content distribution read failed.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_read_NVC(self):		try:			print("To check the nucleotide composition bias. ")			self.os_system('read_NVC.py -i '+self.input_name+' -o '+self.out_rseqc+self.output_name)			if os.path.getsize(self.out_rseqc+self.output_name+'.NVC.xls')>1:				print("The deviation of nucleotide composition was checked successfully.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.NVC_plot.pdf',self.out_png+self.output_name+'_NVC_plot.png')			else:				print("Failure to check the nucleotide composition bias.")				sys.exit()		except:			print("Error,failure to check the nucleotide composition bias.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_read_quality(self):		try:			print("Calculating the quality of reads. ")			self.os_system('read_quality.py -i '+self.input_name+' -o '+self.out_rseqc+self.output_name)						if os.path.getsize(self.out_rseqc+self.output_name+'.qual.boxplot.pdf')>3611:				print("The quality of reads was calculated successfully.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.qual.boxplot.pdf',self.out_png+self.output_name+'_qual_boxplot.png')			else:				print("Failure to calculate the quality of reads.")				sys.exit()			except:			print("Error,failure to calculate the quality of reads.")			sys.exit()		print('#############################################################################################')		return	################################################	def my_RPKM_saturation(self):		try:			print("To resample a series of subsets from total RNA reads and then calculate RPKM value using each subset. ")			if operator.eq(self.layout,"PE"):				self.os_system('RPKM_saturation.py -d "1++,1--,2+-,2-+" -i '+self.input_name+' -o '+self.out_rseqc+self.output_name+' -r ./files/'+self.species+'_RefSeq.bed')			else:				self.os_system('RPKM_saturation.py -i '+self.input_name+' -o '+self.out_rseqc+self.output_name+' -r ./files/'+self.species+'_RefSeq.bed')			if os.path.getsize(self.out_rseqc+self.output_name+'.eRPKM.xls')>1:				print("Resampling a series of subsets from total RNA readings, and then using each subset to calculate the rpkm value successfully.")				self.pdf_to_png(self.out_rseqc+self.output_name+'.saturation.pdf',self.out_png+self.output_name+'_saturation.png')			else:				print("Failure to resample a series of subsets from total RNA reads and then calculate RPKM value using each subset. ")				sys.exit()		except:			print("Error,failure to resample a series of subsets from total RNA reads and then calculate RPKM value using each subset. ")			sys.exit()		print('#############################################################################################')		return	def set_read_ALIGNMENT_LENGTH(self,read_ALIGNMENT_LENGTH):		self.read_ALIGNMENT_LENGTH = read_ALIGNMENT_LENGTH		return